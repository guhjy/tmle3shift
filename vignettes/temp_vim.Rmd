---
title: "Variable Importance Made Simple"
author: "[Nima S. Hejazi](https://nimahejazi.org), [Jeremy R.
  Coyle](https://github.com/jeremyrcoyle), and [Mark J. van der
  Laan](https://vanderlaan-lab.org)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: vignette-refs.bib
vignette: >
  %\VignetteIndexEntry{Variable Importance Mad Simple}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r options, echo=FALSE, eval=FALSE}
options(scipen=999)
```

## Introduction

```{r install, eval=FALSE}
# NOT RUN
remotes::install_github("tlverse/tmle3@vim")
remotes::install_github("tlverse/tmle3shift@targeted-msm")
```

To start, let's load the packages we'll use and set a seed for simulation:

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(data.table)
library(foreach)
library(condensier)
library(ranger)
library(sl3)
library(tmle3)
library(tmle3shift)
set.seed(429153)
```

---

## Simulate Data

```{r sim_data}
# simulate simple data for tmle-shift sketch
n_obs <- 1000 # number of observations
n_w <- 1 # number of baseline covariates
tx_mult <- 2 # multiplier for the effect of W = 1 on the treatment

# baseline covariates -- simple, binary
W <- as.numeric(replicate(n_w, rbinom(n_obs, 1, 0.5)))

# create treatment based on baseline W
A <- as.numeric(rnorm(n_obs, mean = tx_mult * W, sd = 1))

# create outcome as a linear function of A, W + white noise
Y <- A + W + rnorm(n_obs, mean = 0, sd = 1)

# organize data and nodes for tmle3
data <- data.table(W, A, Y)
node_list <- list(W = "W", A = "A", Y = "Y")
```

```{r data_nodes}
# organize data and nodes for tmle3
data <- data.table(W, A, Y)
node_list <- list(W = "W", A = "A", Y = "Y")
```

We now have an observed data structure (`data`) and a specification of the role
that each variable in the data set plays as the nodes in a DAG.

---

## Methodology

### _Interlude:_ Constructing Optimal Stacked Regressions with `sl3`

To easily incorporate ensemble machine learning into the estimation procedure,
we rely on the facilities provided in the [`sl3` R
package](https://sl3.tlverse.org). For a complete guide on using the `sl3` R
package, consider consulting https://sl3.tlverse.org, or https://tlverse.org for
the [`tlverse` ecosystem](https://github.com/tlverse), of which `sl3` is a major
part.

Using the framework provided by the [`sl3` package](https://sl3.tlverse.org),
the nuisance parameters of the TML estimator may be fit with ensemble learning,
using the cross-validation framework of the Super Learner algorithm of
@vdl2007super.

```{r sl3_lrnrs}
# learners used for outcome regression
lrn1 <- Lrnr_mean$new()
lrn2 <- Lrnr_glm$new()
lrn3 <- Lrnr_ranger$new()
sl_lrn <- Lrnr_sl$new(
  learners = list(lrn1, lrn2, lrn3),
  metalearner = Lrnr_nnls$new()
)

# learners used for intervention conditional density estimatoin
lrn1_dens <- Lrnr_condensier$new(
  nbins = 25, bin_estimator = lrn2,
  bin_method = "dhist"
)
lrn2_dens <- Lrnr_condensier$new(
  nbins = 15, bin_estimator = lrn3,
  bin_method = "dhist"
)
lrn3_dens <- Lrnr_condensier$new(
  nbins = 20, bin_estimator = lrn2,
  bin_method = "dhist"
)
lrn4_dens <- Lrnr_condensier$new(
  nbins = 40, bin_estimator = lrn1,
  bin_method = "dhist"
)
sl_lrn_dens <- Lrnr_sl$new(
  learners = list(lrn1_dens, lrn2_dens, lrn3_dens, lrn4_dens),
  metalearner = Lrnr_solnp_density$new()
)
```

```{r make_lrnr_list}
# specify outcome and treatment regressions and create learner list
Q_learner <- sl_lrn
g_learner <- sl_lrn_dens
learner_list <- list(Y = Q_learner, A = g_learner)
```

### Initializing `vimshift` through its `tmle3_Spec`

To start, we will initialize a specification for the TMLE of our parameter of
interest (called a `tmle3_Spec` in the `tlverse` nomenclature) simply by calling
`tmle_shift`. We specify the argument `shift_grid = seq(-0.5, 0.5, by = 0.5)`
when initializing the `tmle3_Spec` object to communicate that we're interested
in assessing the mean counterfactual outcome over a grid of shifts `r seq(-0.5,
0.5, by = 0.5)` on the scale of the treatment $A$ (note that the numerical
choice of shift is an arbitrarily chosen set of values for this example).

```{r vim_spec_init}
# what's the grid of shifts we wish to consider?
delta_grid <- seq(-1, 1, 0.5)

# initialize a tmle specification
tmle_spec <- tmle_vimshift_delta(shift_grid = delta_grid,
                                 max_shifted_ratio = 2)
```

Instead, one may invoke the `tmle3` convenience function to fit the series of
TML estimators (one for each parameter defined by the grid delta) in a single
function call:

```{r fit_tmle_auto}
# fit the TML estimator for variable importane
tmle_vim_fit <- tmle3_vim(tmle_spec, data, node_list, learner_list)
tmle_vim_fit
```

```{r msm_fit}
msm <- trend_msm(tmle_fit, delta_grid)
msm
```

